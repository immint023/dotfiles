{
  "version": 3,
  "sources": ["../src/context.tsx", "../src/hooks/useKubectx.ts", "../src/services/kubectx.service.ts", "../src/lib/cli.parser.ts", "../src/lib/cli.ts"],
  "sourcesContent": ["import { ActionPanel, Color, CopyToClipboardAction, Icon, List } from \"@raycast/api\";\nimport React from \"react\";\n\nimport useKubectx from \"./hooks/useKubectx\";\n\nconst Command: React.FC = () => {\n  const { contextes, switchContext, currentContext, loading } = useKubectx();\n\n  const getAccessoryIcon = (contextName: string) => {\n    if (contextName !== currentContext) {\n      return { source: Icon.Checkmark };\n    }\n\n    return { source: Icon.Checkmark, tintColor: Color.Green };\n  };\n\n  const handleSwitchContext = async (contextName: string) => {\n    await switchContext(contextName);\n  };\n\n  return (\n    <List isLoading={loading} searchBarPlaceholder=\"Filter by title...\">\n      {contextes.map((item) => (\n        <List.Item\n          key={item}\n          title={item}\n          icon={getAccessoryIcon(item)}\n          actions={\n            <ActionPanel>\n              <ActionPanel.Item\n                title={`Switch to ${item}`}\n                icon={Icon.Checkmark}\n                onAction={() => handleSwitchContext(item)}\n              />\n              <CopyToClipboardAction content={item} />\n            </ActionPanel>\n          }\n        />\n      ))}\n    </List>\n  );\n};\n\nexport default Command;\n", "import { closeMainWindow, showToast, ToastStyle } from \"@raycast/api\";\nimport { useEffect, useState } from \"react\";\n\nimport kubectxService from \"../services/kubectx.service\";\n\nconst useKubectx = () => {\n  const [loading, setLoading] = useState(true);\n  const [contextes, setContextes] = useState<string[]>([]);\n  const [currentContext, setCurrrentContext] = useState<string>();\n\n  const getData = async () => {\n    try {\n      const allContextes = await kubectxService.getAllContextes();\n      const _currentContext = await kubectxService.getCurrentContext();\n\n      setContextes(allContextes);\n      setCurrrentContext(_currentContext);\n    } catch (e) {\n      showToast(ToastStyle.Failure, \"An error occurred\", \"Please make sure you have installed kubectx correctly\");\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    getData();\n  }, []);\n\n  const switchContext = async (newContextName: string) => {\n    try {\n      await kubectxService.switchContext(newContextName);\n      setCurrrentContext(newContextName);\n      await closeMainWindow();\n    } catch (e) {\n      showToast(ToastStyle.Failure, \"An error occurred\");\n    }\n  };\n\n  return { loading, contextes, currentContext, switchContext };\n};\n\nexport default useKubectx;\n", "import { execFile } from \"child_process\";\nimport util from \"util\";\n\nimport { commandOutputToArray } from \"../lib/cli.parser\";\nimport { getBrewExecutablePath, getKubeConfig } from \"../lib/cli\";\n\nconst execFilePromise = util.promisify(execFile);\n\nconst path = getBrewExecutablePath(\"kubectx\");\n\nconst kubeConfig = getKubeConfig();\n\nif (kubeConfig) {\n  process.env.KUBECONFIG = kubeConfig;\n}\n\nexport const getCurrentContext = async () => {\n  const { stdout } = await execFilePromise(`${path}`, [\"-c\"]);\n\n  const currentContext = commandOutputToArray(stdout)[0];\n\n  return currentContext;\n};\n\nexport const getAllContextes = async () => {\n  const { stdout } = await execFilePromise(`${path}`);\n\n  const contextes = commandOutputToArray(stdout);\n\n  return contextes;\n};\n\nexport const switchContext = async (newContextName: string) => {\n  await execFilePromise(`${path}`, [newContextName]);\n};\n\nexport default {\n  getAllContextes,\n  getCurrentContext,\n  switchContext,\n};\n", "export const commandOutputToArray = (output: string) => {\n  const array = output.split(\"\\n\").filter(Boolean);\n\n  return array;\n};\n", "import { getPreferenceValues } from \"@raycast/api\";\nimport { accessSync, constants } from \"fs\";\n\nexport const getBrewExecutablePath = (packageName: string) => {\n  const preferences: { kubectxPath: string } = getPreferenceValues();\n\n  if (preferences.kubectxPath) {\n    return preferences.kubectxPath;\n  }\n\n  const possiblePaths = [`/usr/local/bin/${packageName}`, `/opt/homebrew/bin/${packageName}`];\n\n  let validPath = packageName;\n\n  possiblePaths.some((path) => {\n    try {\n      accessSync(path, constants.X_OK);\n\n      validPath = path;\n\n      return true;\n    } catch (e) {\n      return false;\n    }\n  });\n\n  return validPath;\n};\n\nexport const getKubeConfig = () => {\n  const preferences: { kubeConfig: string } = getPreferenceValues();\n  return preferences.kubeConfig || null;\n};\n"],
  "mappings": "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",
  "names": ["context_exports", "__export", "context_default", "__toCommonJS", "import_api", "import_api", "import_react", "import_child_process", "import_util", "commandOutputToArray", "output", "import_api", "import_fs", "getBrewExecutablePath", "packageName", "preferences", "possiblePaths", "validPath", "path", "getKubeConfig", "execFilePromise", "util", "path", "getBrewExecutablePath", "kubeConfig", "getKubeConfig", "getCurrentContext", "stdout", "commandOutputToArray", "getAllContextes", "switchContext", "newContextName", "kubectx_service_default", "useKubectx", "loading", "setLoading", "contextes", "setContextes", "currentContext", "setCurrrentContext", "getData", "allContextes", "kubectx_service_default", "_currentContext", "newContextName", "useKubectx_default", "import_jsx_runtime", "Command", "contextes", "switchContext", "currentContext", "loading", "useKubectx_default", "getAccessoryIcon", "contextName", "handleSwitchContext", "item", "context_default"]
}
